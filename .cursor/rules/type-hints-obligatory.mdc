---
alwaysApply: true
description: "Type hints obrigatÃ³rios em todo o cÃ³digo para prevenir erros de runtime"
---

# ğŸ“ TYPE HINTS OBRIGATÃ“RIOS

## âŒ CÃ“DIGO SEM TYPE HINTS (PROIBIDO)

### FunÃ§Ãµes sem type hints
```python
# âŒ PERIGOSO - Sem type hints
def validate_username(username):
    """FunÃ§Ã£o sem type hints - pode causar erros"""
    if len(username) < 3:
        return False
    return True

def run_maigret_search(username, max_sites=500):
    """ParÃ¢metros e retorno sem tipos definidos"""
    # Pode retornar qualquer coisa
    # ParÃ¢metros podem ser de qualquer tipo
    pass

def process_results(data):
    """Sem tipo definido - pode quebrar em runtime"""
    return data.get('results')  # Erro se data nÃ£o for dict
```

### VariÃ¡veis sem tipo
```python
# âŒ PERIGOSO - VariÃ¡veis sem tipo definido
results = []  # O que Ã© armazenado aqui?
config = {}   # Que estrutura tem este dict?
status = None # Pode ser qualquer coisa
```

## âœ… TYPE HINTS OBRIGATÃ“RIOS

### Imports obrigatÃ³rios
```python
# âœ… OBRIGATÃ“RIO - Imports de tipos obrigatÃ³rios
from typing import (
    Dict, List, Optional, Union, Any, Tuple,
    Callable, TypeVar, Generic, Literal
)

# Para compatibilidade com Python < 3.10
from __future__ import annotations
```

### FunÃ§Ãµes com type hints completos
```python
# âœ… OBRIGATÃ“RIO - Type hints completos obrigatÃ³rios
def validate_username_secure(username: str) -> str:
    """
    ValidaÃ§Ã£o robusta de username com sanitizaÃ§Ã£o completa

    Args:
        username (str): Username a ser validado

    Returns:
        str: Username sanitizado e validado

    Raises:
        ValueError: Se username for invÃ¡lido ou inseguro
    """
    # ImplementaÃ§Ã£o com type hints obrigatÃ³rios
    pass

def run_maigret_secure(
    username: str,
    max_sites: int = 500,
    timeout_sec: int = 30,
    enable_recursion: bool = True,
    id_type: str = "username",
    tags: Optional[List[str]] = None
) -> Dict[str, Any]:
    """
    ExecuÃ§Ã£o segura do Maigret com sanitizaÃ§Ã£o completa

    Args:
        username: Username validado e sanitizado
        max_sites: MÃ¡ximo de sites a verificar
        timeout_sec: Timeout em segundos
        enable_recursion: Habilitar busca recursiva
        id_type: Tipo de ID a buscar
        tags: Lista de tags para filtrar sites

    Returns:
        Dict com resultado da execuÃ§Ã£o

    Raises:
        ValueError: Se parÃ¢metros forem invÃ¡lidos
        subprocess.TimeoutExpired: Se timeout for atingido
    """
    # ImplementaÃ§Ã£o com type hints obrigatÃ³rios
    pass

def validate_and_display_username(username: str) -> Tuple[bool, str, str]:
    """
    Valida username e retorna resultado para exibiÃ§Ã£o no Streamlit

    Args:
        username: Username a ser validado

    Returns:
        Tuple[bool, str, str]: (is_valid, clean_username, error_message)
    """
    # ImplementaÃ§Ã£o com type hints obrigatÃ³rios
    pass
```

### Estruturas de dados com tipos definidos
```python
# âœ… OBRIGATÃ“RIO - Tipos para estruturas de dados
from typing import TypedDict, NamedTuple

class SearchResult(TypedDict):
    """Estrutura obrigatÃ³ria para resultados de busca"""
    nome: str
    url: str
    status: str
    confiabilidade: int
    dados_extras: Dict[str, Any]
    parseado: bool

class MaigretExecutionResult(TypedDict):
    """Estrutura obrigatÃ³ria para resultados de execuÃ§Ã£o"""
    success: bool
    returncode: int
    stdout: str
    stderr: str
    username: str
    timestamp: int
    timeout_used: int
    processed_results: List[SearchResult]
    sites_found: int
    error: Optional[str]

class SearchConfig(NamedTuple):
    """ConfiguraÃ§Ã£o de busca com tipos obrigatÃ³rios"""
    timeout: int
    max_sites: int
    max_connections: int
    enable_recursion: bool
    id_type: Literal["username", "yandex_public_id", "gaia_id", "vk_id"]
    tags: Optional[List[str]]

# Uso obrigatÃ³rio
def process_maigret_results(raw_data: Dict[str, Any]) -> List[SearchResult]:
    """Processa resultados brutos do Maigret"""
    processed_results: List[SearchResult] = []

    if isinstance(raw_data, dict):
        for site_name, site_data in raw_data.items():
            if isinstance(site_data, dict):
                result: SearchResult = {
                    "nome": site_name,
                    "url": site_data.get("url_user", ""),
                    "status": "encontrado" if site_data.get("status", {}).get("status") == "CLAIMED" else "nÃ£o encontrado",
                    "confiabilidade": 85 if site_data.get("status", {}).get("status") == "CLAIMED" else 0,
                    "dados_extras": site_data.get("ids", {}),
                    "parseado": site_data.get("is_parsed", False)
                }
                processed_results.append(result)

    return processed_results
```

### VariÃ¡veis com tipos explÃ­citos
```python
# âœ… OBRIGATÃ“RIO - VariÃ¡veis com tipos obrigatÃ³rios
from typing import List, Dict, Optional

def init_session_state() -> None:
    """Inicializa o estado da sessÃ£o com tipos obrigatÃ³rios"""

    # Estado de busca
    search_history: List[Dict[str, Any]] = []
    st.session_state.search_history = search_history

    current_results: Optional[List[SearchResult]] = None
    st.session_state.current_results = current_results

    search_in_progress: bool = False
    st.session_state.search_in_progress = search_in_progress

    # ConfiguraÃ§Ãµes com tipos especÃ­ficos
    timeout: int = 30
    max_sites: int = 500
    debug_mode: bool = False

    st.session_state.timeout = timeout
    st.session_state.max_sites = max_sites
    st.session_state.debug_mode = debug_mode

def safe_get_session_value(key: str, default: Any = None) -> Any:
    """ObtÃ©m valor do session_state com tipo seguro"""
    try:
        return st.session_state.get(key, default)
    except Exception:
        return default

def get_search_config() -> SearchConfig:
    """ObtÃ©m configuraÃ§Ã£o de busca com tipos obrigatÃ³rios"""
    return SearchConfig(
        timeout=safe_get_session_value('timeout', 30),
        max_sites=safe_get_session_value('max_sites', 500),
        max_connections=safe_get_session_value('max_connections', 50),
        enable_recursion=safe_get_session_value('enable_recursion', True),
        id_type=safe_get_session_value('id_type', 'username'),
        tags=safe_get_session_value('tags')
    )
```

### Callbacks e funÃ§Ãµes de alta ordem
```python
# âœ… OBRIGATÃ“RIO - Type hints para callbacks
from typing import Callable, Protocol

class SearchCallback(Protocol):
    """Protocolo obrigatÃ³rio para callbacks de busca"""
    def __call__(self, username: str, result: MaigretExecutionResult) -> None:
        ...

def register_search_callback(callback: SearchCallback) -> None:
    """Registra callback de busca com tipo obrigatÃ³rio"""
    # ImplementaÃ§Ã£o
    pass

def perform_search_with_callback(
    username: str,
    callback: Optional[SearchCallback] = None
) -> MaigretExecutionResult:
    """Executa busca com callback opcional"""
    result = run_maigret_secure(username)

    if callback is not None:
        callback(username, result)

    return result
```

### ExceÃ§Ãµes com tipos especÃ­ficos
```python
# âœ… OBRIGATÃ“RIO - ExceÃ§Ãµes com tipos obrigatÃ³rios
from typing import NoReturn

class ValidationError(ValueError):
    """Erro de validaÃ§Ã£o com informaÃ§Ãµes estruturadas"""

    def __init__(self, message: str, field: str, value: Any) -> None:
        super().__init__(message)
        self.field: str = field
        self.value: Any = value

class SearchError(Exception):
    """Erro de busca com contexto"""

    def __init__(
        self,
        message: str,
        username: str,
        returncode: Optional[int] = None,
        stderr: Optional[str] = None
    ) -> None:
        super().__init__(message)
        self.username: str = username
        self.returncode: Optional[int] = returncode
        self.stderr: Optional[str] = None

def raise_validation_error(field: str, value: Any, reason: str) -> NoReturn:
    """Levanta erro de validaÃ§Ã£o com tipo obrigatÃ³rio"""
    message = f"Validation failed for {field}: {reason}"
    raise ValidationError(message, field, value)

def handle_search_error(error: Exception, username: str) -> SearchError:
    """Converte exceÃ§Ãµes em SearchError com tipos obrigatÃ³rios"""
    if isinstance(error, subprocess.TimeoutExpired):
        return SearchError(
            f"Search timeout for username: {username}",
            username=username
        )
    elif isinstance(error, ValidationError):
        return SearchError(
            f"Validation error: {str(error)}",
            username=username
        )
    else:
        return SearchError(
            f"Unexpected error: {str(error)}",
            username=username
        )
```

### Generics para reutilizaÃ§Ã£o
```python
# âœ… OBRIGATÃ“RIO - Generics para cÃ³digo reutilizÃ¡vel
from typing import TypeVar, Generic, Iterable

T = TypeVar('T')
K = TypeVar('K')
V = TypeVar('V')

class SafeDict(Generic[K, V]):
    """DicionÃ¡rio seguro com validaÃ§Ã£o obrigatÃ³ria"""

    def __init__(self) -> None:
        self._data: Dict[K, V] = {}

    def get_safe(self, key: K, default: V) -> V:
        """ObtÃ©m valor com tipo seguro obrigatÃ³rio"""
        return self._data.get(key, default)

    def set_safe(self, key: K, value: V) -> None:
        """Define valor com validaÃ§Ã£o obrigatÃ³ria"""
        if not isinstance(key, (str, int)):
            raise TypeError(f"Key must be str or int, got {type(key)}")
        self._data[key] = value

def filter_by_type(items: Iterable[T], item_type: type) -> List[T]:
    """Filtra itens por tipo com generics obrigatÃ³rios"""
    return [item for item in items if isinstance(item, item_type)]

def safe_map(func: Callable[[T], V], items: Iterable[T]) -> List[V]:
    """Mapeia funÃ§Ã£o sobre itens com tipos obrigatÃ³rios"""
    result: List[V] = []
    for item in items:
        try:
            result.append(func(item))
        except Exception:
            # Log error mas continua processamento
            continue
    return result
```

## ğŸ› ï¸ FERRAMENTAS DE VERIFICAÃ‡ÃƒO

### mypy obrigatÃ³rio
```ini
# mypy.ini - ConfiguraÃ§Ã£o obrigatÃ³ria
[mypy]
python_version = 3.11
warn_return_any = true
warn_unused_configs = true
disallow_untyped_defs = true
disallow_incomplete_defs = true
check_untyped_defs = true
disallow_untyped_decorators = true
no_implicit_optional = true
warn_redundant_casts = true
warn_unused_ignores = true
warn_no_return = true
warn_unreachable = true
strict_equality = true

# MÃ³dulos especÃ­ficos
[mypy-streamlit.*]
ignore_missing_imports = true
```

### Script de verificaÃ§Ã£o obrigatÃ³rio
```python
# scripts/type_check.py - VerificaÃ§Ã£o obrigatÃ³ria
#!/usr/bin/env python3
"""
Script obrigatÃ³rio para verificaÃ§Ã£o de tipos
"""

import subprocess
import sys
from pathlib import Path

def run_mypy_check() -> bool:
    """Executa verificaÃ§Ã£o mypy obrigatÃ³ria"""
    print("ğŸ” Executando verificaÃ§Ã£o de tipos (mypy)...")

    try:
        result = subprocess.run(
            ["mypy", "app.py", "validation.py", "maigret_service.py"],
            capture_output=True,
            text=True
        )

        if result.returncode == 0:
            print("âœ… Todos os tipos estÃ£o corretos!")
            return True
        else:
            print("âŒ Erros de tipo encontrados:")
            print(result.stdout)
            if result.stderr:
                print("Erros:", result.stderr)
            return False

    except FileNotFoundError:
        print("âŒ mypy nÃ£o encontrado. Instale com: pip install mypy")
        return False

def run_type_coverage() -> bool:
    """Verifica cobertura de tipos obrigatÃ³ria"""
    print("ğŸ“Š Verificando cobertura de tipos...")

    try:
        from mypy import api
        result = api.run([
            "--config-file", "mypy.ini",
            "--show-traceback",
            "."
        ])

        if result[2] == 0:  # CÃ³digo de saÃ­da
            print("âœ… Cobertura de tipos adequada!")
            return True
        else:
            print("âŒ Cobertura de tipos insuficiente:")
            print(result[0])  # stdout
            return False

    except ImportError:
        print("âŒ mypy nÃ£o disponÃ­vel para anÃ¡lise de cobertura")
        return False

def main() -> int:
    """FunÃ§Ã£o principal obrigatÃ³ria"""

    print("ğŸ”§ VERIFICAÃ‡ÃƒO DE TIPOS OBRIGATÃ“RIA")
    print("=" * 40)

    # VerificaÃ§Ãµes obrigatÃ³rias
    checks = [
        run_mypy_check,
        run_type_coverage
    ]

    all_passed = True
    for check in checks:
        if not check():
            all_passed = False

    if all_passed:
        print("\nâœ… TODAS AS VERIFICAÃ‡Ã•ES DE TIPO PASSARAM!")
        return 0
    else:
        print("\nâŒ ALGUMAS VERIFICAÃ‡Ã•ES DE TIPO FALHARAM!")
        print("ğŸ’¡ Corrija os erros de tipo antes de continuar.")
        return 1

if __name__ == "__main__":
    sys.exit(main())
```

## ğŸ“‹ CHECKLIST DE TYPE HINTS OBRIGATÃ“RIOS

- [ ] Imports de tipos obrigatÃ³rios adicionados
- [ ] Todas as funÃ§Ãµes tÃªm type hints completos
- [ ] Estruturas de dados usam TypedDict/NamedTuple
- [ ] VariÃ¡veis tÃªm tipos explÃ­citos
- [ ] ExceÃ§Ãµes customizadas tÃªm tipos definidos
- [ ] Generics usados para cÃ³digo reutilizÃ¡vel
- [ ] mypy configurado e executando sem erros
- [ ] Script de verificaÃ§Ã£o implementado
- [ ] Type hints validados antes de commit