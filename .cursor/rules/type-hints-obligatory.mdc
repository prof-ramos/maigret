---
alwaysApply: true
description: "Type hints obrigat√≥rios em todo o c√≥digo para prevenir erros de runtime"
---

# üìù TYPE HINTS OBRIGAT√ìRIOS

## ‚ùå C√ìDIGO SEM TYPE HINTS (PROIBIDO)

### Fun√ß√µes sem type hints
```python
# ‚ùå PERIGOSO - Sem type hints
def validate_username(username):
    """Fun√ß√£o sem type hints - pode causar erros"""
    if len(username) < 3:
        return False
    return True

def run_maigret_search(username, max_sites=500):
    """Par√¢metros e retorno sem tipos definidos"""
    # Pode retornar qualquer coisa
    # Par√¢metros podem ser de qualquer tipo
    pass

def process_results(data):
    """Sem tipo definido - pode quebrar em runtime"""
    return data.get('results')  # Erro se data n√£o for dict
```

### Vari√°veis sem tipo
```python
# ‚ùå PERIGOSO - Vari√°veis sem tipo definido
results = []  # O que √© armazenado aqui?
config = {}   # Que estrutura tem este dict?
status = None # Pode ser qualquer coisa
```

## ‚úÖ TYPE HINTS OBRIGAT√ìRIOS

### Imports obrigat√≥rios
```python
# ‚úÖ OBRIGAT√ìRIO - Imports de tipos obrigat√≥rios
from typing import (
    Dict, List, Optional, Union, Any, Tuple,
    Callable, TypeVar, Generic, Literal
)

# Para compatibilidade com Python < 3.10
from __future__ import annotations
```

### Fun√ß√µes com type hints completos
```python
# ‚úÖ OBRIGAT√ìRIO - Type hints completos obrigat√≥rios
def validate_username_secure(username: str) -> str:
    """
    Valida√ß√£o robusta de username com sanitiza√ß√£o completa

    Args:
        username (str): Username a ser validado

    Returns:
        str: Username sanitizado e validado

    Raises:
        ValueError: Se username for inv√°lido ou inseguro
    """
    # Implementa√ß√£o com type hints obrigat√≥rios
    pass

def run_maigret_secure(
    username: str,
    max_sites: int = 500,
    timeout_sec: int = 30,
    enable_recursion: bool = True,
    id_type: str = "username",
    tags: Optional[List[str]] = None
) -> Dict[str, Any]:
    """
    Execu√ß√£o segura do Maigret com sanitiza√ß√£o completa

    Args:
        username: Username validado e sanitizado
        max_sites: M√°ximo de sites a verificar
        timeout_sec: Timeout em segundos
        enable_recursion: Habilitar busca recursiva
        id_type: Tipo de ID a buscar
        tags: Lista de tags para filtrar sites

    Returns:
        Dict com resultado da execu√ß√£o

    Raises:
        ValueError: Se par√¢metros forem inv√°lidos
        subprocess.TimeoutExpired: Se timeout for atingido
    """
    # Implementa√ß√£o com type hints obrigat√≥rios
    pass

def validate_and_display_username(username: str) -> Tuple[bool, str, str]:
    """
    Valida username e retorna resultado para exibi√ß√£o no Streamlit

    Args:
        username: Username a ser validado

    Returns:
        Tuple[bool, str, str]: (is_valid, clean_username, error_message)
    """
    # Implementa√ß√£o com type hints obrigat√≥rios
    pass
```

### Estruturas de dados com tipos definidos
```python
# ‚úÖ OBRIGAT√ìRIO - Tipos para estruturas de dados
from typing import TypedDict, NamedTuple

class SearchResult(TypedDict):
    """Estrutura obrigat√≥ria para resultados de busca"""
    nome: str
    url: str
    status: str
    confiabilidade: int
    dados_extras: Dict[str, Any]
    parseado: bool

class MaigretExecutionResult(TypedDict):
    """Estrutura obrigat√≥ria para resultados de execu√ß√£o"""
    success: bool
    returncode: int
    stdout: str
    stderr: str
    username: str
    timestamp: int
    timeout_used: int
    processed_results: List[SearchResult]
    sites_found: int
    error: Optional[str]

class SearchConfig(NamedTuple):
    """Configura√ß√£o de busca com tipos obrigat√≥rios"""
    timeout: int
    max_sites: int
    max_connections: int
    enable_recursion: bool
    id_type: Literal["username", "yandex_public_id", "gaia_id", "vk_id"]
    tags: Optional[List[str]]

# Uso obrigat√≥rio
def process_maigret_results(raw_data: Dict[str, Any]) -> List[SearchResult]:
    """Processa resultados brutos do Maigret"""
    processed_results: List[SearchResult] = []

    if isinstance(raw_data, dict):
        for site_name, site_data in raw_data.items():
            if isinstance(site_data, dict):
                result: SearchResult = {
                    "nome": site_name,
                    "url": site_data.get("url_user", ""),
                    "status": "encontrado" if site_data.get("status", {}).get("status") == "CLAIMED" else "n√£o encontrado",
                    "confiabilidade": 85 if site_data.get("status", {}).get("status") == "CLAIMED" else 0,
                    "dados_extras": site_data.get("ids", {}),
                    "parseado": site_data.get("is_parsed", False)
                }
                processed_results.append(result)

    return processed_results
```

### Vari√°veis com tipos expl√≠citos
```python
# ‚úÖ OBRIGAT√ìRIO - Vari√°veis com tipos obrigat√≥rios
from typing import List, Dict, Optional

def init_session_state() -> None:
    """Inicializa o estado da sess√£o com tipos obrigat√≥rios"""

    # Estado de busca
    search_history: List[Dict[str, Any]] = []
    st.session_state.search_history = search_history

    current_results: Optional[List[SearchResult]] = None
    st.session_state.current_results = current_results

    search_in_progress: bool = False
    st.session_state.search_in_progress = search_in_progress

    # Configura√ß√µes com tipos espec√≠ficos
    timeout: int = 30
    max_sites: int = 500
    debug_mode: bool = False

    st.session_state.timeout = timeout
    st.session_state.max_sites = max_sites
    st.session_state.debug_mode = debug_mode

def safe_get_session_value(key: str, default: Any = None) -> Any:
    """Obt√©m valor do session_state com tipo seguro"""
    try:
        return st.session_state.get(key, default)
    except Exception:
        return default

def get_search_config() -> SearchConfig:
    """Obt√©m configura√ß√£o de busca com tipos obrigat√≥rios"""
    return SearchConfig(
        timeout=safe_get_session_value('timeout', 30),
        max_sites=safe_get_session_value('max_sites', 500),
        max_connections=safe_get_session_value('max_connections', 50),
        enable_recursion=safe_get_session_value('enable_recursion', True),
        id_type=safe_get_session_value('id_type', 'username'),
        tags=safe_get_session_value('tags')
    )
```

### Callbacks e fun√ß√µes de alta ordem
```python
# ‚úÖ OBRIGAT√ìRIO - Type hints para callbacks
from typing import Callable, Protocol

class SearchCallback(Protocol):
    """Protocolo obrigat√≥rio para callbacks de busca"""
    def __call__(self, username: str, result: MaigretExecutionResult) -> None:
        ...

def register_search_callback(callback: SearchCallback) -> None:
    """Registra callback de busca com tipo obrigat√≥rio"""
    # Implementa√ß√£o
    pass

def perform_search_with_callback(
    username: str,
    callback: Optional[SearchCallback] = None
) -> MaigretExecutionResult:
    """Executa busca com callback opcional"""
    result = run_maigret_secure(username)

    if callback is not None:
        callback(username, result)

    return result
```

### Exce√ß√µes com tipos espec√≠ficos
```python
# ‚úÖ OBRIGAT√ìRIO - Exce√ß√µes com tipos obrigat√≥rios
from typing import NoReturn

class ValidationError(ValueError):
    """Erro de valida√ß√£o com informa√ß√µes estruturadas"""

    def __init__(self, message: str, field: str, value: Any) -> None:
        super().__init__(message)
        self.field: str = field
        self.value: Any = value

class SearchError(Exception):
    """Erro de busca com contexto"""

    def __init__(
        self,
        message: str,
        username: str,
        returncode: Optional[int] = None,
        stderr: Optional[str] = None
    ) -> None:
        super().__init__(message)
        self.username: str = username
        self.returncode: Optional[int] = returncode
        self.stderr: Optional[str] = None

def raise_validation_error(field: str, value: Any, reason: str) -> NoReturn:
    """Levanta erro de valida√ß√£o com tipo obrigat√≥rio"""
    message = f"Validation failed for {field}: {reason}"
    raise ValidationError(message, field, value)

def handle_search_error(error: Exception, username: str) -> SearchError:
    """Converte exce√ß√µes em SearchError com tipos obrigat√≥rios"""
    if isinstance(error, subprocess.TimeoutExpired):
        return SearchError(
            f"Search timeout for username: {username}",
            username=username
        )
    elif isinstance(error, ValidationError):
        return SearchError(
            f"Validation error: {str(error)}",
            username=username
        )
    else:
        return SearchError(
            f"Unexpected error: {str(error)}",
            username=username
        )
```

### Generics para reutiliza√ß√£o
```python
# ‚úÖ OBRIGAT√ìRIO - Generics para c√≥digo reutiliz√°vel
from typing import TypeVar, Generic, Iterable

T = TypeVar('T')
K = TypeVar('K')
V = TypeVar('V')

class SafeDict(Generic[K, V]):
    """Dicion√°rio seguro com valida√ß√£o obrigat√≥ria"""

    def __init__(self) -> None:
        self._data: Dict[K, V] = {}

    def get_safe(self, key: K, default: V) -> V:
        """Obt√©m valor com tipo seguro obrigat√≥rio"""
        return self._data.get(key, default)

    def set_safe(self, key: K, value: V) -> None:
        """Define valor com valida√ß√£o obrigat√≥ria"""
        if not isinstance(key, (str, int)):
            raise TypeError(f"Key must be str or int, got {type(key)}")
        self._data[key] = value

def filter_by_type(items: Iterable[T], item_type: type) -> List[T]:
    """Filtra itens por tipo com generics obrigat√≥rios"""
    return [item for item in items if isinstance(item, item_type)]

def safe_map(func: Callable[[T], V], items: Iterable[T]) -> List[V]:
    """Mapeia fun√ß√£o sobre itens com tipos obrigat√≥rios"""
    result: List[V] = []
    for item in items:
        try:
            result.append(func(item))
        except Exception:
            # Log error mas continua processamento
            continue
    return result
```

## üõ†Ô∏è FERRAMENTAS DE VERIFICA√á√ÉO

### mypy obrigat√≥rio
```ini
# mypy.ini - Configura√ß√£o obrigat√≥ria
[mypy]
python_version = 3.11
warn_return_any = true
warn_unused_configs = true
disallow_untyped_defs = true
disallow_incomplete_defs = true
check_untyped_defs = true
disallow_untyped_decorators = true
no_implicit_optional = true
warn_redundant_casts = true
warn_unused_ignores = true
warn_no_return = true
warn_unreachable = true
strict_equality = true

# M√≥dulos espec√≠ficos
[mypy-streamlit.*]
ignore_missing_imports = true
```

### Script de verifica√ß√£o obrigat√≥rio
```python
# scripts/type_check.py - Verifica√ß√£o obrigat√≥ria
#!/usr/bin/env python3
"""
Script obrigat√≥rio para verifica√ß√£o de tipos
"""

import subprocess
import sys
from pathlib import Path

def run_mypy_check() -> bool:
    """Executa verifica√ß√£o mypy obrigat√≥ria"""
    print("üîç Executando verifica√ß√£o de tipos (mypy)...")

    try:
        result = subprocess.run(
            ["mypy", "app.py", "validation.py", "maigret_service.py"],
            capture_output=True,
            text=True
        )

        if result.returncode == 0:
            print("‚úÖ Todos os tipos est√£o corretos!")
            return True
        else:
            print("‚ùå Erros de tipo encontrados:")
            print(result.stdout)
            if result.stderr:
                print("Erros:", result.stderr)
            return False

    except FileNotFoundError:
        print("‚ùå mypy n√£o encontrado. Instale com: pip install mypy")
        return False

def run_type_coverage() -> bool:
    """Verifica cobertura de tipos obrigat√≥ria"""
    print("üìä Verificando cobertura de tipos...")

    try:
        from mypy import api
        result = api.run([
            "--config-file", "mypy.ini",
            "--show-traceback",
            "."
        ])

        if result[2] == 0:  # C√≥digo de sa√≠da
            print("‚úÖ Cobertura de tipos adequada!")
            return True
        else:
            print("‚ùå Cobertura de tipos insuficiente:")
            print(result[0])  # stdout
            return False

    except ImportError:
        print("‚ùå mypy n√£o dispon√≠vel para an√°lise de cobertura")
        return False

def main() -> int:
    """Fun√ß√£o principal obrigat√≥ria"""

    print("üîß VERIFICA√á√ÉO DE TIPOS OBRIGAT√ìRIA")
    print("=" * 40)

    # Verifica√ß√µes obrigat√≥rias
    checks = [
        run_mypy_check,
        run_type_coverage
    ]

    all_passed = True
    for check in checks:
        if not check():
            all_passed = False

    if all_passed:
        print("\n‚úÖ TODAS AS VERIFICA√á√ïES DE TIPO PASSARAM!")
        return 0
    else:
        print("\n‚ùå ALGUMAS VERIFICA√á√ïES DE TIPO FALHARAM!")
        print("üí° Corrija os erros de tipo antes de continuar.")
        return 1

if __name__ == "__main__":
    sys.exit(main())
```

## üìã CHECKLIST DE TYPE HINTS OBRIGAT√ìRIOS

- [ ] Imports de tipos obrigat√≥rios adicionados
- [ ] Todas as fun√ß√µes t√™m type hints completos
- [ ] Estruturas de dados usam TypedDict/NamedTuple
- [ ] Vari√°veis t√™m tipos expl√≠citos
- [ ] Exce√ß√µes customizadas t√™m tipos definidos
- [ ] Generics usados para c√≥digo reutiliz√°vel
- [ ] mypy configurado e executando sem erros
- [ ] Script de verifica√ß√£o implementado
- [ ] Type hints validados antes de commit