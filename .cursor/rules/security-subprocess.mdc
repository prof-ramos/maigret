---
alwaysApply: true
description: "Garantir execu√ß√£o segura de subprocess para prevenir inje√ß√£o de comandos"
---

# üîí SEGURAN√áA CR√çTICA: Subprocess Seguro

## ‚ùå PR√ÅTICAS PROIBIDAS

### Nunca usar `shell=True` com entrada de usu√°rio
```python
# ‚ùå PERIGOSO - Permite inje√ß√£o de comandos
def run_command(user_input):
    cmd = f"maigret {user_input} --json"  # String interpolation vulner√°vel
    result = subprocess.run(cmd, shell=True)  # shell=True √© perigoso
    return result
```

### Nunca concatenar comandos com entrada de usu√°rio
```python
# ‚ùå PERIGOSO - Inje√ß√£o de comandos poss√≠vel
username = request.args.get('username')
cmd = f"maigret {username} --timeout 30"  # Inje√ß√£o poss√≠vel
```

## ‚úÖ PR√ÅTICAS OBRIGAT√ìRIAS

### Sempre usar lista de argumentos
```python
# ‚úÖ SEGURO - Lista de argumentos previne inje√ß√£o
import subprocess
from typing import List, Optional

def run_maigret_secure(
    username: str,
    timeout: int = 30,
    max_sites: int = 500
) -> dict:
    """Execu√ß√£o segura do Maigret com valida√ß√£o completa"""

    # 1. Validar entrada primeiro
    clean_username = validate_username_secure(username)

    # 2. Construir comando como lista (SEGURO)
    cmd: List[str] = [
        "maigret",
        clean_username,
        "--json", "simple",
        "--timeout", str(timeout),
        "--top-sites", str(max_sites)
    ]

    # 3. Configurar ambiente seguro
    env = {
        "PATH": "/usr/local/bin:/usr/bin:/bin",  # PATH limitado
        "LANG": "C.UTF-8",
        "HOME": "/tmp"
    }

    # 4. Executar SEM shell=True
    result = subprocess.run(
        cmd,
        capture_output=True,
        text=True,
        timeout=timeout + 60,  # Buffer de seguran√ßa
        check=False,
        env=env,  # Ambiente seguro
        cwd="/tmp"  # Working directory seguro
    )

    return {
        "success": result.returncode == 0,
        "returncode": result.returncode,
        "stdout": result.stdout[:10000],  # Limitar tamanho
        "stderr": result.stderr[:5000],   # Limitar tamanho
    }
```

### Sempre validar entrada antes de usar em subprocess
```python
# ‚úÖ SEGURO - Valida√ß√£o obrigat√≥ria
def validate_username_secure(username: str) -> str:
    """Valida√ß√£o robusta que previne inje√ß√£o de comandos"""

    if not isinstance(username, str):
        raise ValueError("Username deve ser string")

    if not username or not username.strip():
        raise ValueError("Username n√£o pode estar vazio")

    username = username.strip()

    # Verificar comprimento
    if not (3 <= len(username) <= 50):
        raise ValueError("Username deve ter entre 3 e 50 caracteres")

    # Caracteres permitidos apenas
    allowed_chars = set(string.ascii_letters + string.digits + '._-')
    if not set(username).issubset(allowed_chars):
        raise ValueError(f"Caracteres n√£o permitidos detectados")

    # Verificar padr√µes perigosos
    dangerous_patterns = [
        '&&', '||', ';', '|', '`', '$', '!',
        '..', '/.', '\\.',
        'rm ', 'sudo', 'chmod', 'chown', 'passwd',
        "'", '"', '--', '/*', '*/',
        '<script', '</script', 'javascript:', 'data:',
    ]

    username_lower = username.lower()
    for pattern in dangerous_patterns:
        if pattern in username_lower:
            raise ValueError(f"Padr√£o proibido detectado: {pattern}")

    return username
```

## üö® VERIFICA√á√ïES AUTOM√ÅTICAS

### Sempre verificar antes de executar
- ‚úÖ Entrada foi validada com `validate_username_secure()`
- ‚úÖ Comando √© constru√≠do como lista, n√£o string
- ‚úÖ `shell=True` NUNCA √© usado
- ‚úÖ Timeout √© definido
- ‚úÖ Ambiente √© limitado
- ‚úÖ Working directory √© seguro

## üìã CHECKLIST DE SEGURAN√áA

- [ ] Input sanitization implementada
- [ ] Lista de argumentos usada (n√£o string)
- [ ] `shell=True` removido
- [ ] Timeout configurado
- [ ] Ambiente seguro definido
- [ ] Working directory seguro
- [ ] Testes de seguran√ßa implementados
- [ ] Logging de seguran√ßa adicionado