---
alwaysApply: true
description: "Garantir implementa√ß√£o obrigat√≥ria de testes e cobertura m√≠nima"
---

# üß™ TESTES OBRIGAT√ìRIOS E COBERTURA M√çNIMA

## ‚ùå C√ìDIGO SEM TESTES (PROIBIDO)

### Fun√ß√µes cr√≠ticas sem testes
```python
# ‚ùå PERIGOSO - Fun√ß√£o cr√≠tica sem testes
def run_maigret_secure(username, **kwargs):
    """Esta fun√ß√£o √© cr√≠tica mas n√£o tem testes"""
    # 500+ linhas de c√≥digo sem cobertura de testes
    # Pode conter vulnerabilidades n√£o detectadas
    pass

def validate_username(username):
    """Valida√ß√£o b√°sica sem testes de seguran√ßa"""
    # Pode ser facilmente burlada
    pass
```

## ‚úÖ ESTRUTURA DE TESTES OBRIGAT√ìRIA

### Estrutura de diret√≥rios obrigat√≥ria
```
tests/
‚îú‚îÄ‚îÄ __init__.py
‚îú‚îÄ‚îÄ conftest.py                 # Fixtures globais
‚îú‚îÄ‚îÄ unit/                      # Testes unit√°rios
‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îú‚îÄ‚îÄ test_validation.py     # Testes de valida√ß√£o
‚îÇ   ‚îú‚îÄ‚îÄ test_security.py       # Testes de seguran√ßa
‚îÇ   ‚îî‚îÄ‚îÄ test_functions.py      # Testes de fun√ß√µes
‚îú‚îÄ‚îÄ integration/               # Testes de integra√ß√£o
‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îú‚îÄ‚îÄ test_streamlit_app.py  # Testes da interface
‚îÇ   ‚îî‚îÄ‚îÄ test_maigret_integration.py
‚îú‚îÄ‚îÄ security/                  # Testes de seguran√ßa espec√≠ficos
‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îî‚îÄ‚îÄ test_subprocess_security.py
‚îî‚îÄ‚îÄ fixtures/                  # Dados de teste
    ‚îú‚îÄ‚îÄ sample_results.json
    ‚îî‚îÄ‚îÄ mock_responses.json
```

### Configura√ß√£o pytest obrigat√≥ria
```ini
# pytest.ini - Configura√ß√£o obrigat√≥ria
[tool:pytest]
testpaths = tests
python_files = test_*.py *_test.py
python_classes = Test*
python_functions = test_*
addopts =
    --verbose
    --tb=short
    --cov=app
    --cov-report=html
    --cov-report=term-missing
    --cov-report=xml
    --cov-fail-under=60
    --timeout=300
markers =
    unit: Testes unit√°rios
    integration: Testes de integra√ß√£o
    security: Testes de seguran√ßa
    slow: Testes que demoram muito
filterwarnings =
    ignore::DeprecationWarning
    ignore::PendingDeprecationWarning
```

### Fixtures obrigat√≥rias
```python
# tests/conftest.py - Fixtures globais obrigat√≥rias
import pytest
import tempfile
from unittest.mock import Mock
from typing import Dict, Any

@pytest.fixture
def temp_dir():
    """Diret√≥rio tempor√°rio para testes"""
    with tempfile.TemporaryDirectory() as tmpdir:
        yield tmpdir

@pytest.fixture
def mock_subprocess():
    """Mock seguro do subprocess"""
    with patch('subprocess.run') as mock_run:
        mock_run.return_value = Mock(
            returncode=0,
            stdout='{"sites": {"github": {"status": "found"}}}',
            stderr='',
        )
        yield mock_run

@pytest.fixture
def sample_maigret_result() -> Dict[str, Any]:
    """Resultado exemplo do Maigret"""
    return {
        "sites": {
            "GitHub": {
                "status": "found",
                "url": "https://github.com/testuser",
                "response_time": 0.5
            },
            "Twitter": {
                "status": "not_found",
                "url": "https://twitter.com/testuser"
            }
        },
        "search_stats": {
            "total_sites": 2,
            "found": 1,
            "not_found": 1
        }
    }

@pytest.fixture
def valid_usernames():
    """Usernames v√°lidos para testes"""
    return [
        "user123",
        "test.user",
        "my-username",
        "user_name",
        "abc",
        "a" * 50  # M√°ximo permitido
    ]

@pytest.fixture
def malicious_inputs():
    """Entradas maliciosas para testes de seguran√ßa"""
    return [
        "user; ls -la",
        "user && cat /etc/passwd",
        "user || echo 'hacked'",
        "user | grep secret",
        "user `whoami`",
        "user $(id)",
        "user; rm -rf /",
        "user && sudo su",
        "user; chmod 777 *",
        "../../../etc/passwd",
        "<script>alert('xss')</script>",
        "javascript:alert(1)",
        "user'; DROP TABLE users;--",
        'user" OR 1=1--',
    ]
```

## üß™ TESTES UNIT√ÅRIOS OBRIGAT√ìRIOS

### Testes de valida√ß√£o obrigat√≥rios
```python
# tests/unit/test_validation.py
import pytest
from app import validate_username_secure

class TestUsernameValidation:
    """Testes obrigat√≥rios de valida√ß√£o de username"""

    def test_valid_usernames(self, valid_usernames):
        """Testa usernames v√°lidos - OBRIGAT√ìRIO"""
        for username in valid_usernames:
            result = validate_username_secure(username)
            assert result == username

    def test_invalid_lengths(self):
        """Testa usernames com tamanho inv√°lido - OBRIGAT√ìRIO"""
        # Muito curtos
        with pytest.raises(ValueError, match="entre 3 e 50 caracteres"):
            validate_username_secure("ab")

        # Muito longos
        with pytest.raises(ValueError, match="entre 3 e 50 caracteres"):
            validate_username_secure("a" * 51)

    def test_invalid_characters(self):
        """Testa caracteres n√£o permitidos - OBRIGAT√ìRIO"""
        invalid_usernames = [
            "user@domain.com",  # @
            "user space",       # espa√ßo
            "user/path",        # /
            "user\\path",       # \\
            "user#hash",        # #
            "user%percent",     # %
            "user&and",         # &
        ]

        for username in invalid_usernames:
            with pytest.raises(ValueError, match="Caracteres n√£o permitidos"):
                validate_username_secure(username)

    def test_command_injection_attempts(self, malicious_inputs):
        """Testa tentativas de inje√ß√£o de comandos - CR√çTICO"""
        for malicious in malicious_inputs:
            with pytest.raises(ValueError):
                validate_username_secure(malicious)

    @pytest.mark.parametrize("invalid_input", [
        None,           # None
        123,            # int
        [],             # list
        {},             # dict
        "",             # string vazia
        "   ",          # s√≥ espa√ßos
    ])
    def test_invalid_input_types(self, invalid_input):
        """Testa tipos de entrada inv√°lidos - OBRIGAT√ìRIO"""
        with pytest.raises(ValueError):
            validate_username_secure(invalid_input)
```

### Testes de seguran√ßa obrigat√≥rios
```python
# tests/security/test_subprocess_security.py
import pytest
from unittest.mock import patch, Mock
from app import run_maigret_secure

class TestSubprocessSecurity:
    """Testes de seguran√ßa de subprocess - CR√çTICOS"""

    @patch('subprocess.run')
    def test_secure_command_construction(self, mock_run):
        """Testa constru√ß√£o segura do comando - OBRIGAT√ìRIO"""
        mock_run.return_value = Mock(
            returncode=0,
            stdout='{"sites": {}}',
            stderr=''
        )

        result = run_maigret_secure("testuser")

        # Verificar que comando foi constru√≠do como lista
        args, kwargs = mock_run.call_args
        cmd = args[0]

        assert isinstance(cmd, list)
        assert cmd[0] == "maigret"
        assert cmd[1] == "testuser"
        assert "shell" not in kwargs or kwargs["shell"] is False

    @patch('subprocess.run')
    def test_parameter_sanitization(self, mock_run):
        """Testa sanitiza√ß√£o de par√¢metros - OBRIGAT√ìRIO"""
        mock_run.return_value = Mock(returncode=0, stdout='{}', stderr='')

        result = run_maigret_secure(
            username="testuser",
            timeout_sec=60,
            max_connections=25
        )

        # Verificar sanitiza√ß√£o
        args, kwargs = mock_run.call_args
        cmd = args[0]

        assert "60" in cmd      # timeout sanitizado
        assert "25" in cmd      # connections sanitizado

    def test_invalid_parameters(self):
        """Testa par√¢metros inv√°lidos - OBRIGAT√ìRIO"""
        # Timeout inv√°lido
        with pytest.raises(ValueError, match="Timeout deve estar"):
            run_maigret_secure("testuser", timeout_sec=1000)

        # Connections inv√°lidas
        with pytest.raises(ValueError, match="max_connections deve estar"):
            run_maigret_secure("testuser", max_connections=500)

    @patch('subprocess.run')
    def test_environment_security(self, mock_run):
        """Testa configura√ß√£o segura do ambiente - OBRIGAT√ìRIO"""
        mock_run.return_value = Mock(returncode=0, stdout='{}', stderr='')

        run_maigret_secure("testuser")

        args, kwargs = mock_run.call_args

        # Verificar ambiente limitado
        assert 'env' in kwargs
        env = kwargs['env']
        assert env['PATH'] == "/usr/local/bin:/usr/bin:/bin"
        assert env['HOME'] == "/tmp"

        # Verificar working directory seguro
        assert kwargs.get('cwd') == "/tmp"
```

## üîó TESTES DE INTEGRA√á√ÉO OBRIGAT√ìRIOS

### Testes da interface Streamlit
```python
# tests/integration/test_streamlit_app.py
import pytest
from streamlit.testing.v1 import AppTest
from unittest.mock import patch, Mock

class TestStreamlitIntegration:
    """Testes de integra√ß√£o da interface - OBRIGAT√ìRIOS"""

    def test_app_loads_successfully(self):
        """Testa se a aplica√ß√£o carrega sem erros - OBRIGAT√ìRIO"""
        at = AppTest.from_file("app.py")
        at.run()

        # Verificar que n√£o h√° exce√ß√µes
        assert not at.exception

        # Verificar elementos b√°sicos da UI
        assert len(at.title) > 0  # Tem t√≠tulo
        assert len(at.text_input) > 0  # Tem input de texto
        assert len(at.button) > 0  # Tem bot√µes

    @patch('app.run_maigret_secure')
    def test_search_functionality(self, mock_maigret):
        """Testa funcionalidade de busca completa - OBRIGAT√ìRIO"""
        # Configurar mock
        mock_maigret.return_value = {
            "success": True,
            "returncode": 0,
            "data": {
                "sites": {
                    "GitHub": {"status": "found", "url": "https://github.com/testuser"}
                }
            },
            "sites_found": 1
        }

        at = AppTest.from_file("app.py")
        at.run()

        # Simular entrada de usu√°rio
        at.text_input[0].input("testuser").run()

        # Clicar no bot√£o de busca
        search_button = None
        for button in at.button:
            if "Buscar" in button.label or "üîç" in button.label:
                search_button = button
                break

        assert search_button is not None
        search_button.click().run()

        # Verificar que Maigret foi chamado
        mock_maigret.assert_called_once()

        # Verificar que n√£o h√° exce√ß√µes
        assert not at.exception

    @patch('app.run_maigret_secure')
    def test_error_handling_in_ui(self, mock_maigret):
        """Testa tratamento de erros na interface - OBRIGAT√ìRIO"""
        # Configurar mock para simular erro
        mock_maigret.side_effect = ValueError("Teste de erro")

        at = AppTest.from_file("app.py")
        at.run()

        # Simular busca com erro
        at.text_input[0].input("testuser").run()

        # Clicar no bot√£o de busca
        for button in at.button:
            if "Buscar" in button.label or "üîç" in button.label:
                button.click().run()
                break

        # Verificar que erro foi tratado (n√£o h√° exception n√£o capturada)
        assert not at.exception

        # Verificar se h√° mensagem de erro na UI
        error_found = any("erro" in str(element).lower() for element in at.error)
        assert error_found
```

## üìä COBERTURA M√çNIMA OBRIGAT√ìRIA

### Meta de cobertura por componente
```python
# Cobertura m√≠nima obrigat√≥ria por arquivo cr√≠tico
COVERAGE_REQUIREMENTS = {
    "app.py": 80,           # Arquivo principal - alta cobertura
    "validation.py": 95,    # Seguran√ßa cr√≠tica - cobertura m√°xima
    "security.py": 95,      # Seguran√ßa - cobertura m√°xima
    "utils.py": 70,         # Utilit√°rios - cobertura m√©dia
}

# Comando para verificar cobertura
# pytest --cov=. --cov-report=term-missing --cov-fail-under=60
```

### Relat√≥rio de cobertura obrigat√≥rio
```python
# scripts/coverage_analysis.py - An√°lise obrigat√≥ria
def analyze_coverage_xml(xml_path: str) -> dict:
    """Analisa arquivo XML de cobertura - OBRIGAT√ìRIA"""

    if not Path(xml_path).exists():
        print(f"‚ùå Arquivo {xml_path} n√£o encontrado")
        return {}

    # An√°lise detalhada obrigat√≥ria
    # Implementar an√°lise de linhas n√£o cobertas
    # Identificar fun√ß√µes cr√≠ticas sem testes
    pass

def generate_coverage_report(coverage_data: dict) -> str:
    """Gera relat√≥rio de cobertura em texto - OBRIGAT√ìRIA"""

    # Relat√≥rio detalhado obrigat√≥rio
    # M√©tricas por arquivo
    # Linhas cr√≠ticas n√£o cobertas
    # Recomenda√ß√µes para aumentar cobertura
    pass
```

## üìã CHECKLIST DE TESTES OBRIGAT√ìRIOS

- [ ] Estrutura de testes criada
- [ ] Testes unit√°rios implementados (60%+ cobertura)
- [ ] Testes de seguran√ßa implementados
- [ ] Testes de integra√ß√£o implementados
- [ ] Fixtures configuradas
- [ ] CI/CD configurado para testes
- [ ] Cobertura m√≠nima atingida (60%)
- [ ] Relat√≥rios de cobertura gerados
- [ ] Testes executados automaticamente